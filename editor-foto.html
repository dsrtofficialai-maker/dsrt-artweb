import React, { useRef, useState, useEffect } from "react";

type Tool =
  | "brush"
  | "eraser"
  | "text"
  | "shapes"
  | "rotate"
  | "flip"
  | "fill"
  | "zoom"
  | "filter"
  | "adjust"
  | "layers"
  | "hd";

type HistoryState = ImageData[];

const EditorFinal: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [tool, setTool] = useState<Tool | null>(null);
  const [brushColor, setBrushColor] = useState("#00ffd5");
  const [brushSize, setBrushSize] = useState(10);
  const [isDrawing, setIsDrawing] = useState(false);
  const [lastPos, setLastPos] = useState<{ x: number; y: number } | null>(
    null
  );
  const [rotation, setRotation] = useState(0);
  const [brightness, setBrightness] = useState(100);
  const [contrast, setContrast] = useState(100);
  const [history, setHistory] = useState<HistoryState>([]);
  const [historyStep, setHistoryStep] = useState(0);

  // Save history
  const saveHistory = () => {
    const ctx = canvasRef.current?.getContext("2d");
    if (!ctx || !canvasRef.current) return;
    const imageData = ctx.getImageData(
      0,
      0,
      canvasRef.current.width,
      canvasRef.current.height
    );
    const newHistory = history.slice(0, historyStep);
    newHistory.push(imageData);
    setHistory(newHistory);
    setHistoryStep(newHistory.length);
  };

  // Undo / Redo
  const undo = () => {
    if (historyStep <= 1) return;
    const ctx = canvasRef.current?.getContext("2d");
    if (!ctx || !canvasRef.current) return;
    const prev = history[historyStep - 2];
    ctx.putImageData(prev, 0, 0);
    setHistoryStep(historyStep - 1);
  };
  const redo = () => {
    if (historyStep >= history.length) return;
    const ctx = canvasRef.current?.getContext("2d");
    if (!ctx || !canvasRef.current) return;
    const next = history[historyStep];
    ctx.putImageData(next, 0, 0);
    setHistoryStep(historyStep + 1);
  };

  // Start drawing
  const startDraw = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (tool !== "brush" && tool !== "eraser") return;
    setIsDrawing(true);
    const rect = canvasRef.current!.getBoundingClientRect();
    setLastPos({ x: e.clientX - rect.left, y: e.clientY - rect.top });
  };
  const endDraw = () => {
    if (isDrawing) saveHistory();
    setIsDrawing(false);
    setLastPos(null);
  };
  const draw = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawing || !canvasRef.current || !lastPos) return;
    const ctx = canvasRef.current.getContext("2d");
    if (!ctx) return;
    const rect = canvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    ctx.strokeStyle = tool === "eraser" ? "#0d1117" : brushColor;
    ctx.lineWidth = brushSize;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(lastPos.x, lastPos.y);
    ctx.lineTo(x, y);
    ctx.stroke();
    setLastPos({ x, y });
  };

  // Rotate
  const applyRotation = (angle: number) => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext("2d");
    if (!ctx) return;
    const temp = ctx.getImageData(
      0,
      0,
      canvasRef.current.width,
      canvasRef.current.height
    );
    const offCanvas = document.createElement("canvas");
    offCanvas.width = temp.width;
    offCanvas.height = temp.height;
    offCanvas.getContext("2d")!.putImageData(temp, 0, 0);
    ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
    ctx.save();
    ctx.translate(canvasRef.current.width / 2, canvasRef.current.height / 2);
    ctx.rotate(((rotation + angle) * Math.PI) / 180);
    ctx.drawImage(offCanvas, -canvasRef.current.width / 2, -canvasRef.current.height / 2);
    ctx.restore();
    setRotation(rotation + angle);
    saveHistory();
  };

  // Filters
  useEffect(() => {
    if (!canvasRef.current) return;
    const ctx = canvasRef.current.getContext("2d");
    if (!ctx) return;
    ctx.filter = `brightness(${brightness}%) contrast(${contrast}%)`;
  }, [brightness, contrast]);

  // Export
  const exportImage = () => {
    if (!canvasRef.current) return;
    const data = canvasRef.current.toDataURL("image/png");
    const link = document.createElement("a");
    link.href = data;
    link.download = "dsrt-export.png";
    link.click();
  };

  return (
    <div className="flex flex-col md:flex-row h-screen bg-[#0b1520] text-[#00ffd5]">
      {/* Sidebar */}
      <div className="w-20 md:w-28 bg-[#161b22] flex flex-col p-2 gap-2 overflow-y-auto">
        <button onClick={() => setTool("brush")}>ğŸ–Œï¸</button>
        <button onClick={() => setTool("eraser")}>ğŸ©¹</button>
        <button onClick={() => setTool("rotate")}>ğŸ”„</button>
        <button onClick={() => setTool("flip")}>â†•ï¸</button>
        <button onClick={() => setTool("fill")}>ğŸª£</button>
        <button onClick={() => setTool("filter")}>ğŸ¨</button>
        <button onClick={() => setTool("text")}>ğŸ”¤</button>
        <button onClick={() => setTool("shapes")}>â¬›</button>
        <button onClick={() => setTool("layers")}>ğŸ“‘</button>
        <button onClick={() => setTool("hd")}>HD</button>
      </div>

      {/* Canvas */}
      <div className="flex-1 flex flex-col items-center justify-center p-3 relative">
        <canvas
          ref={canvasRef}
          width={960}
          height={560}
          className="bg-[#112d38] border-2 border-dashed border-[#00ffd5] rounded-xl w-full max-w-[960px]"
          onMouseDown={startDraw}
          onMouseUp={endDraw}
          onMouseOut={endDraw}
          onMouseMove={draw}
        />

        {/* Brush Controls */}
        {tool === "brush" && (
          <div className="flex gap-2 mt-2">
            <label>
              Brush Size:
              <input
                type="range"
                min={1}
                max={50}
                value={brushSize}
                onChange={(e) => setBrushSize(Number(e.target.value))}
              />
            </label>
            <label>
              Color:
              <input
                type="color"
                value={brushColor}
                onChange={(e) => setBrushColor(e.target.value)}
              />
            </label>
          </div>
        )}

        {/* Rotate Controls */}
        {tool === "rotate" && (
          <div className="flex gap-2 mt-2">
            <button onClick={() => applyRotation(90)}>90Â°</button>
            <button onClick={() => applyRotation(180)}>180Â°</button>
            <button onClick={() => applyRotation(270)}>270Â°</button>
          </div>
        )}

        {/* Filter Controls */}
        {tool === "filter" && (
          <div className="flex gap-2 mt-2">
            <label>
              Brightness:
              <input
                type="range"
                min={0}
                max={200}
                value={brightness}
                onChange={(e) => setBrightness(Number(e.target.value))}
              />
            </label>
            <label>
              Contrast:
              <input
                type="range"
                min={0}
                max={200}
                value={contrast}
                onChange={(e) => setContrast(Number(e.target.value))}
              />
            </label>
          </div>
        )}
      </div>

      {/* Panel */}
      <aside className="w-72 bg-[#161b22] p-3 border-l border-[#00ffd5] overflow-auto">
        <h3 className="text-lg font-semibold mb-2">Properti</h3>
        {tool ? <p>Pengaturan <b>{tool}</b> muncul di sini.</p> : <p>Pilih tool.</p>}
        <div className="flex gap-2 mt-2">
          <button onClick={undo}>Undo</button>
          <button onClick={redo}>Redo</button>
          <button onClick={exportImage}>Export</button>
        </div>
      </aside>
    </div>
  );
};

export default EditorFinal;
